// Do not edit directly!
// This file was generated by camel-quarkus-maven-plugin:update-extension-doc-page
= Core
:page-aliases: extensions/core.adoc
:linkattrs:
:cq-artifact-id: camel-quarkus-core
:cq-native-supported: true
:cq-status: Stable
:cq-status-deprecation: Stable
:cq-description: Camel core functionality and basic Camel languages: Constant, ExchangeProperty, Header, Ref, Ref, Simple and Tokeinze
:cq-deprecated: false
:cq-jvm-since: 0.0.1
:cq-native-since: 0.0.1

[.badges]
[.badge-key]##JVM since##[.badge-supported]##0.0.1## [.badge-key]##Native since##[.badge-supported]##0.0.1##

Camel core functionality and basic Camel languages: Constant, ExchangeProperty, Header, Ref, Ref, Simple and Tokeinze

== What's inside

* xref:{cq-camel-components}:languages:constant-language.adoc[Constant language]
* xref:{cq-camel-components}:languages:exchangeProperty-language.adoc[ExchangeProperty language]
* xref:{cq-camel-components}:languages:file-language.adoc[File language]
* xref:{cq-camel-components}:languages:header-language.adoc[Header language]
* xref:{cq-camel-components}:languages:ref-language.adoc[Ref language]
* xref:{cq-camel-components}:languages:simple-language.adoc[Simple language]
* xref:{cq-camel-components}:languages:tokenize-language.adoc[Tokenize language]

Please refer to the above links for usage and configuration details.

== Maven coordinates

https://code.quarkus.io/?extension-search=camel-quarkus-core[Create a new project with this extension on code.quarkus.io, window="_blank"]

Or add the coordinates to your existing project:

[source,xml]
----
<dependency>
    <groupId>org.apache.camel.quarkus</groupId>
    <artifactId>camel-quarkus-core</artifactId>
</dependency>
----

Check the xref:user-guide/index.adoc[User guide] for more information about writing Camel Quarkus applications.

== Additional Camel Quarkus configuration

=== Simple language

==== Using the OGNL notation
When using the OGNL notation from the simple language, the `camel-quarkus-bean` extension should be used.

For instance, the expression below is accessing the `getAddress()` method on the message body of type `Client`.
[source,java]
---
simple("${body.address}")
---

In such a situation, one should take an additional dependency on the camel-quarkus-bean extension xref:{cq-camel-components}::bean-component.adoc[as described here].
Note that in native mode, some classes may need to be registered for reflection. In the example above, the `Client` class
needs to be link:https://quarkus.io/guides/writing-native-applications-tips#registering-for-reflection[registered for reflection].

==== Using dynamic type resolution in native mode
When dynamically resolving a type from simple expressions like `${mandatoryBodyAs(TYPE)}`, `${type:package.Enum.CONSTANT}` or `$\{body} is TYPE`, it may be needed to register some classes for reflection manually.

For instance, the simple expressions below is dynamically resolving the type `java.nio.ByteBuffer` at runtime:
[source,java]
---
simple("${body} is 'java.nio.ByteBuffer'")
---

As such, the class `java.nio.ByteBuffer` needs to be link:https://quarkus.io/guides/writing-native-applications-tips#registering-for-reflection[registered for reflection].

==== Using the simple language with classpath resources in native mode

If your route is supposed to load a Simple script from classpath, like in the following example

[source,java]
----
from("direct:start").transform().simple("resource:classpath:mysimple.txt");
----

then you need to use Quarkus `quarkus.native.resources.includes` property to include the resource in the native executable
as demonstrated below:

[source,properties]
----
quarkus.native.resources.includes = mysimple.txt
----

More information about selecting resources for inclusion in the native executable can be found at xref:user-guide/native-mode.adoc#embedding-resource-in-native-executable[Embedding resource in native executable].

==== Configuring a custom bean via properties in native mode
When specifying a custom bean via properties in native mode with configuration like `#class:*` or `#type:*`, it may be needed to register some classes for reflection manually.

For instance, the custom bean definition below involves the use of reflection for bean instantiation and setter invocation:
[source,properties]
---
camel.beans.customBeanWithSetterInjection = #class:org.example.PropertiesCustomBeanWithSetterInjection
camel.beans.customBeanWithSetterInjection.counter = 123
---

As such, the class `PropertiesCustomBeanWithSetterInjection` needs to be link:https://quarkus.io/guides/writing-native-applications-tips#registering-for-reflection[registered for reflection], note that field access could be omitted in this case.


[width="100%",cols="80,5,15",options="header"]
|===
| Configuration property | Type | Default


|icon:lock[title=Fixed at build time] [[quarkus.camel.bootstrap.enabled]]`link:#quarkus.camel.bootstrap.enabled[quarkus.camel.bootstrap.enabled]`

When set to true, the `CamelRuntime` will be started automatically.
| `boolean`
| `true`

|icon:lock[title=Fixed at build time] [[quarkus.camel.service.discovery.exclude-patterns]]`link:#quarkus.camel.service.discovery.exclude-patterns[quarkus.camel.service.discovery.exclude-patterns]`

A comma-separated list of Ant-path style patterns to match Camel service definition files in the classpath. The services defined in the matching files will not be discoverable via the `org.apache.camel.spi.FactoryFinder` mechanism. 
 The excludes have higher precedence than includes. The excludes defined here can also be used to veto the discoverability of services included by Camel Quarkus extensions. 
 Example values: `META-INF/services/org/apache/camel/foo/++*++,META-INF/services/org/apache/camel/foo/++**++/bar`
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.service.discovery.include-patterns]]`link:#quarkus.camel.service.discovery.include-patterns[quarkus.camel.service.discovery.include-patterns]`

A comma-separated list of Ant-path style patterns to match Camel service definition files in the classpath. The services defined in the matching files will be discoverable via the `org.apache.camel.spi.FactoryFinder` mechanism unless the given file is excluded via `exclude-patterns`. 
 Note that Camel Quarkus extensions may include some services by default. The services selected here added to those services and the exclusions defined in `exclude-patterns` are applied to the union set. 
 Example values: `META-INF/services/org/apache/camel/foo/++*++,META-INF/services/org/apache/camel/foo/++**++/bar`
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.service.registry.exclude-patterns]]`link:#quarkus.camel.service.registry.exclude-patterns[quarkus.camel.service.registry.exclude-patterns]`

A comma-separated list of Ant-path style patterns to match Camel service definition files in the classpath. The services defined in the matching files will not be added to Camel registry during application's static initialization. 
 The excludes have higher precedence than includes. The excludes defined here can also be used to veto the registration of services included by Camel Quarkus extensions. 
 Example values: `META-INF/services/org/apache/camel/foo/++*++,META-INF/services/org/apache/camel/foo/++**++/bar`
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.service.registry.include-patterns]]`link:#quarkus.camel.service.registry.include-patterns[quarkus.camel.service.registry.include-patterns]`

A comma-separated list of Ant-path style patterns to match Camel service definition files in the classpath. The services defined in the matching files will be added to Camel registry during application's static initialization unless the given file is excluded via `exclude-patterns`. 
 Note that Camel Quarkus extensions may include some services by default. The services selected here added to those services and the exclusions defined in `exclude-patterns` are applied to the union set. 
 Example values: `META-INF/services/org/apache/camel/foo/++*++,META-INF/services/org/apache/camel/foo/++**++/bar`
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.runtime-catalog.components]]`link:#quarkus.camel.runtime-catalog.components[quarkus.camel.runtime-catalog.components]`

If `true` the Runtime Camel Catalog embedded in the application will contain JSON schemas of Camel components available in the application; otherwise component JSON schemas will not be available in the Runtime Camel Catalog and any attempt to access those will result in a RuntimeException. 
 Setting this to `false` helps to reduce the size of the native image. In JVM mode, there is no real benefit of setting this flag to `false` except for making the behavior consistent with native mode.
| `boolean`
| `true`

|icon:lock[title=Fixed at build time] [[quarkus.camel.runtime-catalog.languages]]`link:#quarkus.camel.runtime-catalog.languages[quarkus.camel.runtime-catalog.languages]`

If `true` the Runtime Camel Catalog embedded in the application will contain JSON schemas of Camel languages available in the application; otherwise language JSON schemas will not be available in the Runtime Camel Catalog and any attempt to access those will result in a RuntimeException. 
 Setting this to `false` helps to reduce the size of the native image. In JVM mode, there is no real benefit of setting this flag to `false` except for making the behavior consistent with native mode.
| `boolean`
| `true`

|icon:lock[title=Fixed at build time] [[quarkus.camel.runtime-catalog.dataformats]]`link:#quarkus.camel.runtime-catalog.dataformats[quarkus.camel.runtime-catalog.dataformats]`

If `true` the Runtime Camel Catalog embedded in the application will contain JSON schemas of Camel data formats available in the application; otherwise data format JSON schemas will not be available in the Runtime Camel Catalog and any attempt to access those will result in a RuntimeException. 
 Setting this to `false` helps to reduce the size of the native image. In JVM mode, there is no real benefit of setting this flag to `false` except for making the behavior consistent with native mode.
| `boolean`
| `true`

|icon:lock[title=Fixed at build time] [[quarkus.camel.runtime-catalog.models]]`link:#quarkus.camel.runtime-catalog.models[quarkus.camel.runtime-catalog.models]`

If `true` the Runtime Camel Catalog embedded in the application will contain JSON schemas of Camel EIP models available in the application; otherwise EIP model JSON schemas will not be available in the Runtime Camel Catalog and any attempt to access those will result in a RuntimeException. 
 Setting this to `false` helps to reduce the size of the native image. In JVM mode, there is no real benefit of setting this flag to `false` except for making the behavior consistent with native mode.
| `boolean`
| `true`

|icon:lock[title=Fixed at build time] [[quarkus.camel.routes-discovery.enabled]]`link:#quarkus.camel.routes-discovery.enabled[quarkus.camel.routes-discovery.enabled]`

Enable automatic discovery of routes during static initialization.
| `boolean`
| `true`

|icon:lock[title=Fixed at build time] [[quarkus.camel.routes-discovery.exclude-patterns]]`link:#quarkus.camel.routes-discovery.exclude-patterns[quarkus.camel.routes-discovery.exclude-patterns]`

Used for exclusive filtering scanning of RouteBuilder classes. The exclusive filtering takes precedence over inclusive filtering. The pattern is using Ant-path style pattern. Multiple patterns can be specified separated by comma. For example to exclude all classes starting with Bar use: ++**++/Bar++*++ To exclude all routes form a specific package use: com/mycompany/bar/++*++ To exclude all routes form a specific package and its sub-packages use double wildcards: com/mycompany/bar/++**++ And to exclude all routes from two specific packages use: com/mycompany/bar/++*++,com/mycompany/stuff/++*++
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.routes-discovery.include-patterns]]`link:#quarkus.camel.routes-discovery.include-patterns[quarkus.camel.routes-discovery.include-patterns]`

Used for inclusive filtering scanning of RouteBuilder classes. The exclusive filtering takes precedence over inclusive filtering. The pattern is using Ant-path style pattern. Multiple patterns can be specified separated by comma. For example to include all classes starting with Foo use: ++**++/Foo++*++ To include all routes form a specific package use: com/mycompany/foo/++*++ To include all routes form a specific package and its sub-packages use double wildcards: com/mycompany/foo/++**++ And to include all routes from two specific packages use: com/mycompany/foo/++*++,com/mycompany/stuff/++*++
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.native.resources.exclude-patterns]]`link:#quarkus.camel.native.resources.exclude-patterns[quarkus.camel.native.resources.exclude-patterns]`

Replaced by `quarkus.native.resources.excludes` in Camel Quarkus 2.0.0. Using this property throws an exception at build time.
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.native.resources.include-patterns]]`link:#quarkus.camel.native.resources.include-patterns[quarkus.camel.native.resources.include-patterns]`

Replaced by `quarkus.native.resources.includes` in Camel Quarkus 2.0.0. Using this property throws an exception at build time.
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.native.reflection.exclude-patterns]]`link:#quarkus.camel.native.reflection.exclude-patterns[quarkus.camel.native.reflection.exclude-patterns]`

A comma separated list of Ant-path style patterns to match class names that should be excluded from registering for reflection. Use the class name format as returned by the `java.lang.Class.getName()` method: package segments delimited by period `.` and inner classes by dollar sign `$`. 
 This option narrows down the set selected by `include-patterns`. By default, no classes are excluded. 
 This option cannot be used to unregister classes which have been registered internally by Quarkus extensions.
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.native.reflection.include-patterns]]`link:#quarkus.camel.native.reflection.include-patterns[quarkus.camel.native.reflection.include-patterns]`

A comma separated list of Ant-path style patterns to match class names that should be registered for reflection. Use the class name format as returned by the `java.lang.Class.getName()` method: package segments delimited by period `.` and inner classes by dollar sign `$`. 
 By default, no classes are included. The set selected by this option can be narrowed down by `exclude-patterns`. 
 Note that Quarkus extensions typically register the required classes for reflection by themselves. This option is useful in situations when the built in functionality is not sufficient. 
 Note that this option enables the full reflective access for constructors, fields and methods. If you need a finer grained control, consider using `io.quarkus.runtime.annotations.RegisterForReflection` annotation in your Java code. 
 For this option to work properly, the artifacts containing the selected classes must either contain a Jandex index (`META-INF/jandex.idx`) or they must be registered for indexing using the `quarkus.index-dependency.++*++` family of options in `application.properties` - e.g. quarkus.index-dependency.my-dep.group-id = org.my-group quarkus.index-dependency.my-dep.artifact-id = my-artifact  where `my-dep` is a label of your choice to tell Quarkus that `org.my-group` and with `my-artifact` belong together.
| `string`
| 

|icon:lock[title=Fixed at build time] [[quarkus.camel.csimple.on-build-time-analysis-failure]]`link:#quarkus.camel.csimple.on-build-time-analysis-failure[quarkus.camel.csimple.on-build-time-analysis-failure]`

What to do if it is not possible to extract CSimple expressions from a route definition at build time.
| `org.apache.camel.quarkus.core.CamelConfig.FailureRemedy`
| `warn`

|icon:lock[title=Fixed at build time] [[quarkus.camel.main.enabled]]`link:#quarkus.camel.main.enabled[quarkus.camel.main.enabled]`

If `true` all `camel-main` features are enabled; otherwise no `camel-main` features are enabled. See described the xref:user-guide/configuration.adoc[Configuration] section of Camel Quarkus documentation for more details.
| `boolean`
| `true`

|icon:lock[title=Fixed at build time] [[quarkus.camel.main.shutdown.timeout]]`link:#quarkus.camel.main.shutdown.timeout[quarkus.camel.main.shutdown.timeout]`

A timeout (with millisecond precision) to wait for `CamelMain++#++stop()` to finish
| `java.time.Duration`
| `PT3S`

|icon:lock[title=Fixed at build time] [[quarkus.camel.main.arguments.on-unknown]]`link:#quarkus.camel.main.arguments.on-unknown[quarkus.camel.main.arguments.on-unknown]`

The action to take when `CamelMain` encounters an unknown argument. fail - Prints the `CamelMain` usage statement and throws a `RuntimeException` ignore - Suppresses any warnings and the application startup proceeds as normal warn - Prints the `CamelMain` usage statement but allows the application startup to proceed as normal
| `org.apache.camel.quarkus.core.CamelConfig.FailureRemedy`
| `warn`
|===

[.configuration-legend]
icon:lock[title=Fixed at build time] Configuration property fixed at build time. All other configuration properties are overridable at runtime.

